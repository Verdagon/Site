---
title: Wrapping a Library from Another Language
path: guide/wrapping-a-library
layout: annotated
namespace: m-annotated
---


It often makes sense to use an existing, battle-hardened library that's written in another language instead of writing a new one in Vale. For that reason, Vale has the ability to call out to other libraries.

For example, the Vale standard library calls out to a C library named [Subprocess](https://github.com/sheredom/subprocess.h). It does this by including the C code when the Vale compiler invokes clang under the hood.


This page describes the steps to wrapping a C library:

 1. Make a new Vale project directory.
 1. Add the C library's code to `./native`.
 1. Add some Vale `extern` and `export` functions and structs to `./src`.
 1. Add some the C definitions of those `extern` functions to `./native`.
 1. Use your library from another Vale project.


Keep reading for how to do these steps!


## Step 0: An Example Library

You probably have a library in mind already, but if you don't, here's a tiny made-up library named TRIP that just triples an integer:

<<<<
triple.c:

```
#include <stdint.h>
#include "triple.h"
extern int64_t TRIP_triple(int64_t x) {
  return x * 3;
}
```
////
triple.h:

```
#include <stdint.h>
extern int64_t TRIP_triple(int64_t x);
```
>>>>


The below steps will show what to do with these files.

! If you want, you can turn `triple.c` into a static library `triple.a` with the commands `clang -c -o triple.o triple.c -fPIC` and `ar r triple.a triple.o`. In the below steps, you would use `triple.a` instead of `tiple.c` everywhere.


## Step 1: Make a new Vale project directory

```
$ mkdir ~/mylib
$ mkdir ~/mylib/src
$ mkdir ~/mylib/src/native
```



That `native` subdirectory will contain the library (explained in step 2).


You'll also be writing some functions to facilitate calling between the library and Vale. Parts of those functions will be in the `src` subdirectory, and parts will be in the `native` subdirectory (explained in steps 3 and 4).


## Step 2: Add the Library

The library needs to be either:

 * Source code: `.c` and `.h` files that all live in one common directory. [# This is only a temporary limitation, let us know if this gets in your way and we can explore the best way to handle cases like these.]
 * A static library (a `.a` file) and a header file (a `.h` file).


If using a language other than C, you'll likely need to do the latter.


Put these in the `./native` directory, for example `~/mylib/native/triple.c` and `~/mylib/native/triple.h`.


Vale will include these files in the final `clang` invocation.


## Step 3: Add Vale Functions

Add a vale file to the `src` directory, for example `~/mylib/src/myfuncs.vale`. The name doesn't matter, it just has to end in `.vale`.


For every function in the library's `.h` file, add an `extern` function to your Vale file.


For example, the `extern int64_t TRIP_triple(int64_t x);` in `triple.h` would become this in `myfuncs.vale`:

```
extern func Triple(x i64) i64;
```



See [Externs and Exports](/guide/externs.vmd) for more on how to convert between C types and Vale types.


The above code does *not* call the `TRIP_triple` C function. It calls `mylib_triple` which we'll write in the next step.



## Step 4: Add C Functions

There's one more step: adding the C wrapper function.


Add a .c file to the `native` directory, for example `/mylib/src/native/myfuncs.c`. The name doesn't matter, it just has to end in `.c`.


Add this code:

```
#include "mylib/triple.h"
#include "TRIP_triple.h"
extern int64_t mylib_triple(int64_t x) {
  return TRIP_triple(x);
}
```



! Don't forget to include mylib/triple.h. It's generated by the compiler and contains the correct signature, so that clang can inform you when Vale and C disagree on what the signature should look like. [# Seriously, don't forget this. Most FFI bugs come down to forgetting this header.]


If your function only took and returned integers and booleans, your wrapper library is done! Now you can use it from another Vale project.


If you take or return pointers or structs or strings, we'll talk about that further below.


## Step 5: Use it from another Vale project

You can use your library from another Vale project by including it on the command line like `mylib=~/mylib/src`.


! If you used a static library (`.a`) instead of C code (`.c`) then you'll also need to include that static library on the command line, like `mylib=~/mylib/src mylib=~/mylib/native/triple.a`. [# This will be unnecessary in 0.2.1 and later versions.]


## Strings

For example, let's say our library had a `TRIP_triple_str` function which turns "hello" into "hellohellohello":

```
extern char* TRIP_triple_str(char* src) {
  int src_len = strlen(src);
  char* result = (char*)malloc(src_len * 3 + 1);
  result[0] = 0;
  strncat(result, src, src_len);
  strncat(result, src, src_len);
  strncat(result, src, src_len);
  return result;
}
```



We would still have a pretty simple Vale function:

```
extern func TripleStr(src str) str;
```



However, Vale and C don't really think of strings the same way. In C a string is just a null-terminated character pointer. Vale also puts a length before the characters in memory.


Our C wrapper function will translate between the two:

```
#include "mylib/TripleStr.h"
extern ValeStr* mylib_TripleStr(ValeStr* vale_src) {
  char* c_result = TRIP_triple_str(vale_src->chars);
  free(vale_src);
  ValeStr* vale_result = ValeStrFrom(c_result);
  free(c_result);
  return vale_result;
}
```



Let's break that down.


`vale_src` is the string coming from Vale. It's defined like `typedef struct { ValeInt length; char chars[0]; } ValeStr;` which means the character data is directly after the length integer in memory.


`char* c_result = TRIP_triple_str(vale_src->chars);` is calling `TRIP_triple_str` with the null-terminated string in `ValeStr`'s `chars` field.


`free(vale_src);` frees the string coming from Vale. This is always needed for any pointer coming from Vale. [# Under the hood, Vale always uses `malloc` and copies the data to give to C, so that C can't accidentally corrupt any Vale data. At some point, we might have a way to avoid `malloc`ing, but not yet.]


`ValeStrFrom` will turn a C string into a `ValeStr`. This is one of two convenience functions provided for `ValeStr`s:

 * `ValeStr* ValeStrFrom(char* source);`
 * `ValeStr* ValeStrNew(ValeInt length);` [# The user would call `ValeStrNew` then manually populate the `chars` in the ValeStr.]


`free(c_result)` just frees the string that came from `TRIP_triple_str` because it's not used anywhere anymore.


We then return `vale_result` to the Vale code.


## Structs

(Work in progress)


## Arrays

(Work in progress)


## Pointers

(Work in progress)
