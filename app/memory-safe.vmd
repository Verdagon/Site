---
title: The Most Memory Safe Native Programming Language
realm: normal
path: memory-safe
layout: annotated
namespace: m-annotated
---


Memory safety is an incredibly useful aspect for a programming language. It protects us from maddening bugs, devious vulnerabilities, and _cantankerous shenanigans._


Getting memory safety with predictable performance [# Tracing garbage collection (like in Java) is a great solution for memory safety, but there are cases where more predictable performance is highly desirable, such as in embedded devices, games, or certain kinds of servers.] is quite a challenge! Most languages need to sacrifice memory safety for other features, such as FFI or `unsafe` blocks.


We've discovered a better way to offer memory safety.


# Generational References' Hidden Superpower

Vale starts with a foundation of [generational references](https://verdagon.dev/blog/generational-references). A generational reference is when every object has a "current generation" integer which we increment on free, and every pointer has a "remembered generation" number from the object. When we dereference a pointer, we assert that those two numbers still match. See [Generational References](https://verdagon.dev/blog/generational-references) for a more in-depth explanation!


Most other languages use garbage collection, reference counting, or borrow checking, but we chose generational references because they're [fast](https://verdagon.dev/blog/generational-references) [# They're not just fast, but they could get even faster when we introduce [regions](https://verdagon.dev/blog/zero-cost-refs-regions) and [Hybrid-Generational Memory](https://verdagon.dev/blog/hybrid-generational-memory)] and more flexible than borrow checking, allowing us to use common safe patterns like observers, [higher RAII](https://verdagon.dev/blog/higher-raii-7drl), the dependency injection pattern, delegates, back-references, graphs, and so on.


We also discovered that they enable Vale to have *complete memory safety,* something no native language has been able to achieve.


This is because generational references:

 * Are not reference counted, so if we give one to some extern C code, we don't need to trust it to maintain reference counts to uphold our memory safety. [# For example, when Python code sends a Python object into C, if the C code doesn't correctly call Py_INCREF, it will corrupt Python's memory and cause some mysterious behavior later on in the Python code.]
 * Are able to detect when an object has been deallocated.
 * Require no unsafe blocks, because there is no borrow checker we need to work around.


Generational references are pretty stellar for memory safety. However, there's one remaining problem: what about FFI?


# FFI and Region Isolation

Foreign Function Interface (FFI) is when a language allows calling into another language's code. For example, Objective-C might make a pointer to some data and pass it to C, which might have a bug which corrupts that data.


This is called "leaky safety", and its bugs are very difficult to track down, because their symptoms manifest so far from their cause.


This can also happen when a language has `unsafe` escape hatches. If some `unsafe` code corrupts some memory, it can cause *undefined behavior in safe code.* For example, see this [Rust snippet](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e3614c9920c35662179633b61b98b4d2) where an unsafe block corrupts some memory that's later used by the safe code.


In all these cases, we know that the unsafe language was involved *somewhere* in the chain of events, but since the bugs actually happen later on, in supposedly safe code, there's no easy way to identify _which_ unsafe code was the original culprit.


To solve this, Vale has [Fearless FFI](https://verdagon.dev/blog/fearless-ffi) which *decouples and isolates* unsafe C data from safe Vale data.

 * Separate the safe memory from the unsafe memory (such as the memory managed by C). This includes:
    * Not allowing safe objects to contain unsafe objects.
    * Not allowing unsafe objects to contain safe objects.
    * Using a different stack for the unsafe code.
 * Allowing references between the two:
    * A safe object can contain a reference to an unsafe object.
    * An unsafe object can contain a reference to a safe object, *and it's automatically scrambled*.
 * Enable passing memory between the two by copying, also known as *message passing*.

See [Fearless FFI](https://verdagon.dev/blog/fearless-ffi) for more on this!


This protects us from any bugs in C that might otherwise accidentally corrupt our Vale data. [# We could also protect against malicious code with sandboxing, via webassembly or subprocesses. This is a planned feature, see [Fearless FFI](https://verdagon.dev/blog/fearless-ffi) for more on this!]



# Performance

Generational references are very fast, but if we want that extra sliver of performance, Vale plans to add the [Check Override Operator](https://vale.dev/guide/unsafe#check-override).


! Note that the check override operator, region borrow checker, and hybrid-generational memory are all upcoming features, not available yet. We mention them here to show our plans for balancing safety with speed!


Most generation checks will be skipped by the [region borrow checker](https://verdagon.dev/blog/zero-cost-refs-regions) and [Hybrid-Generational Memory](https://verdagon.dev/blog/hybrid-generational-memory). For example, we recently implemented a [Cellular Automata algorithm](https://verdagon.dev/blog/yak-shave-language-engine-game#the-good-parts), and by our measurements, regions and hybrid-generational memory would eliminate every single generation check in the entire algorithm.


Still, for the occasional generation check that those two might not eliminate, we have the Check Override Operator, which will skip the generation check for a generational reference.


> "But what if a dependency uses a check override operator, and causes memory unsafety? Isn't this just as bad as an unsafe block?"

It would seem so, except for one key detail: the check override operator is *ignored by default for any dependencies.* One must explicitly enable a dependency to ignore its checks.

Most people will be using it with checks on, so everyone will find out very quickly if there's any unsafe behavior in practice. Anyone who wants that extra sliver of performance can then opt-in to skipping the checks in release mode, with a little more confidence that unsafety will be detected by other users of the library, or in development or testing.

And if a user isn't comfortable with that for their situation, they simply stick with the defaults, which ignore the check override operator.


We think this is a perfect tradeoff to allow memory safety when it's critical, while not compromising the safety of the language or ecosystem.


We're also thinking of adding a way to skip all generation checks for a given block of code. [# We might even call it an `unsafe` block, if that doesn't cause confusion with other languages.]


# Tying it All Together

We talked about three mechanisms:

 * Generational references
 * Fearless FFI
 * Check Override Operator

With these measures in place, Vale will be the first completely memory safe native language!


If you're impressed with our [track record so far](https://vale.dev/roadmap) and believe in the direction we're heading, please consider [sponsoring us](https://github.com/sponsors/ValeLang):

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>

With your help, we can bring complete memory safety to programmers everywhere!


<slice new-color="afterword"/>

# Vale's Vision

Vale aims to bring a new way of programming into the world that offers *speed*, *safety*, and *ease of use.*


*The world needs something like this!* Currently, most programming language work is in:

 * High-overhead languages involving reference counting and tracing garbage collection.
 * Complex languages (Ada/Spark, Coq, Rust, Haskell, etc.) which impose higher complexity burden and mental overhead on the programmer.

These are useful, but there is a *vast field of possibilities* in between, waiting to be explored!


Our aim is to explore that space, discover what it has to offer, and make *speed and safety easier than ever before.*


In this quest, we've discovered and implemented a lot of new techniques:

 * [Generational Memory](/blog/generational-references), for a language to ensure an object still exists at the time of dereferencing.
 * [Higher RAII](/blog/raii-next-steps), a form of linear typing that enables destructors with parameters and returns.
 * [Fearless FFI](/blog/fearless-ffi), which allows us to call into C without risk of accidentally corrupting Vale objects.
 * [Perfect Replayability](/blog/perfect-replayability-prototyped), to record all inputs and replay execution, and completely solve heisenbugs and race bugs.


These techniques have also opened up some new emergent possibilities, which we hope to implement:

 * [Region Borrow Checking](/blog/zero-cost-refs-regions), which adds mutable aliasing support to a Rust-like borrow checker.
 * [Hybrid-Generational Memory](/blog/hybrid-generational-memory), which ensures that nobody destroys an object too early, for better optimizations.
 * [Seamless concurrency](https://verdagon.dev/blog/seamless-fearless-structured-concurrency), the ability to launch multiple threads that can access any pre-existing data without data races, without the need for refactoring the code or the data.
 * Object pools and bump-allocators that are memory-safe and decoupled, so no refactoring needed.


We also gain a lot of inspiration from other languages, and are finding new ways to combine their techniques:

 * We can mix an `unsafe` block with Fearless FFI to make a much safer systems programming language!
 * We can mix Erlang's isolation benefits with functional reactive programming to make much more resilient programs!
 * We can mix region borrow checking with Pony's `iso` to support shared mutability.

...plus a lot more interesting ideas to explore!


The Vale programming language is a novel combination of ideas from the research world and original innovations. Our goal is to publish our techniques, even the ones that couldn't fit in Vale, so that the world as a whole can benefit from our work here, not just those who use Vale.


Our medium-term goals:

 * Finish the Region Borrow Checker, to show the world that shared mutability can work with borrow checking!
 * Prototype Hybrid-Generational Memory in Vale, to see how fast and easy we can make single ownership.
 * Publish the Language Simplicity Manifesto, a collection of principles to keep programming languages' learning curves down.
 * Publish the Memory Safety Grimoire, a collection of "memory safety building blocks" that languages can potentially use to make new memory models, just like Vale combined generational references and scope tethering.


We aim to publish articles biweekly on all of these topics, and create and inspire the next generation of fast, safe, and easy programming languages.


If you want to support our work, please consider [sponsoring us on GitHub](https://github.com/sponsors/ValeLang)!

With enough sponsorship, we can:

 * Work on this full-time.
 * Turn the Vale Language Project into a 501(c)(3) non-profit organization.
 * Make Vale into a production-ready language, and push it into the mainstream!

<center>
  <a href="https://github.com/sponsors/ValeLang" class="donate-button">
     <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-heart icon-sponsor mr-1 color-fg-sponsors">
        <path fill-rule="evenodd" d="M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z"></path>
     </svg>
     Sponsor us on GitHub!
  </a>
</center>

